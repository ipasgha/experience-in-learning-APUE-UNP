# Linux系统

## 进程与线程

- 进程的创建方式：fork()系统调用。调用fork()的进程为父进程，新的进程为子进程，子进程只是复制了父进程的程序、数据等。fork()在父进程中返回子进程的pid，在子进程中返回0。
- 进程通信的方式：

  - 管道通信。一个进程可向其中写入字节流，另一个进程可以读取字节流。

  - 信号。进程可以给其所属进程组的其他进程（父进程、兄弟进程、子进程等）发送信号（除0异常SIGFPE、定时器超时SIGALRM、进程中止SIGABRT等）。  

- 与进程相关的系统调用：

  - fork()：创建一个与父进程相同的子进程。
  - waitpid(pid, &status, opts)：调用进程在此处等待子进程。第一个参数使其等待一个特定的子进程，若为-1则等待任意一个子进程。不设置参数则等待所有子进程。第二个参数存储子进程退出状态，第三个参数控制当没有子进程符合要求时进程阻塞或者返回。
  - exec系列：将进程的映像替换。子进程通过调用exec执行用户命令。
  - kill(pid, sig)：向pid发送信号sig。
  - exit(status)：终止进程并返回状态值。

- 进程与线程的实现：

    每个进程都有运行用户程序的用户模式，当它进行系统调用之后，进程陷入内核模式，运行在内核上下文中，修改自身的内存映射，可以访问机器的所有资源，拥有自己的内核堆栈和内核程序计数器。当一个线程因为系统调用而阻塞之后，它的程序计数器和寄存器会被保存下来以便后续运行。

  - 进程通过task_struct结构表示为任务。Linux系统不区分进程、线程、轻量级线程等，而将其统一为任务。一个单线程的进程只有一个任务结构，而多线程的进程的每一个线程都有自己的任务结构。
  
    - 每个task_struct始终存在于内存。
    - Linux与其他Unix兼容而保留pid，pid同样位于task_struct中。
    - 所有task_struct被组织成双向链表，而pid可被映射为各自任务结构的地址从而直接访问进程信息。
  
  - task_struct的信息大致有以下几类：
    - 调度参数：根据CPU时间、睡眠时间、优先级等共同决定。
    - 内存映射：指向代码/数据/堆栈/页表的指针。若进程被调度出内存，则映射至磁盘。
    - 信号：指定进程需要忽略/捕捉/阻塞的信号。
    - 寄存器：用于陷入内核之后保存寄存器值。
    - 系统调用状态：当前系统调用的参数与返回值。
    - 文件描述符表：用于索引被打开文件的inode。
    - 统计数据：指向记录进程使用CPU时间的表。另有进程最多CPU时间、最大堆栈空间、可用页面数等信息。
    - 当前进程状态。

  - fork系统调用具体做了哪些工作：
    - 分配子进程task_struct;  
    - 将子进程task_struct用父进程task_struct内容填充；
    - 分配子进程堆栈空间、用户空间；
    - 用父进程的用户空间数据填充子进程；
    - 为子进程分配pid；
    - 为数据和堆栈复制页表；（写时复制）
    - 设置共享打开文件；
    - 为子进程设置父进程的寄存器。

  - exec系统调用具体做了哪些工作：
    - 寻找可执行程序并验证是否可执行；
    - 读取、验证头文件；
    - 从内核复制变量与环境参数；
    - 释放旧的地址空间，分配新的地址空间；
    - 为堆栈复制变量与环境参数；
    - 复位所有信号并初始化寄存器。
  
  - Linux模糊了进程与线程的区别，并提出新的系统调用clone。该系统调用可以直接创建新进程，也可在当前进程中创建新线程。系统调用形式：pid = clone(function, stackPtr, flags, arg).
    - 新线程从function处开始执行，且只有arg一个参数；
    - 新线程的私有堆栈指针被初始化为stackPtr；
    - flags可以设置新线程与旧线程共享的内容，包括地址空间、文件描述符、目录、pid、父线程、信号等。
    - 为了保持与其他unix的兼容性，每个线程均有自己的任务标识符tid。当调用clone而不共享信息时，新进程获得全新的pid，否则新线程获得原有的pid，在tid上作出区分。
  
- Linux的调度算法

    Linux系统的所有调度均基于内核级线程。所有线程分为三类：实时先入先出、实时轮转、分时。

  - **Linux系统的实时线程并不能确保按规定时间结束，仅仅是优先级更高的线程。实时线程的优先级在0-99，而分时线程的优先级在100-139。**
  - 实时先入先出线程具有最高优先级，他只会被其他更高优先级的实时先入先出线程抢占。
  - 实时轮转线程与实时先入先出线程基本一致，只是多了一个时间片参数。当时间片用完之后插入实时轮转线程列表的尾部。
  - 分时线程由单独算法进行调度，这样可以保证不与实时线程抢占资源。
  - Linux为每个线程分配一个nice值，这个值可用于调整线程静态优先级。
  - Linux中有两种调度算法：O(1)时间调度算法与完全公平调度算法。
  ___

  - O(1)时间调度器：
    - 调度队列组织为两个数组，分别为正在活动数组和过期失效数组。每个数组均包含140个链表头，对应140个优先级。
    - 调度器从正在活动数组中选择优先级最高的任务调度执行。当这个任务用完了时间片（无论是否执行完毕）则将其移入过期失效数组中。
      - 如果这个任务在运行时阻塞，则记录其已用CPU时间，当任务可用之后移入正在活动数组，以允许其用完剩余的CPU时间。
  
    - 正在活动数组为空时交换正在活动数组与过期失效数组。这样可保证低优先级线程不被饿死。
    - 不同优先级的时间片长度不一样。
    - Linux会重新计算每个线程究竟是I/O密集型或是CPU密集型，基于线程执行时间和等待时间计算动态优先级。
      - 一个基本的原则是奖励I/O密集型线程，惩罚CPU密集型线程。
      - 奖惩措施为在其本身优先级上进行增减。
      - 调度器需要为每个线程维护一个变量sleep_arg，该变量在线程被唤醒时增加，在线程被抢占/用完时间片时减少。
  
        - 该变量减少的值用于生成动态优先级。例如：一个线程在时间片内一直在运行，导致sleep_arg减少了5，则对这个任务施以+5的动态优先级，该动态优先级会导致任务优先级下降5级。
        - 动态优先级的范围为-5~+5。
  
    - 优势：可稳定的在常数时间内完成调度。
    - 缺点：计算动态优先级的方法过于复杂且不够完善，处理I/O密集任务时表现很差。

  ___

  - 完全公平调度器：
    - 使用红黑树作为调度队列的数据结构，树的每个节点对应一个任务：
      - 根据任务使用的相对CPU时间长短而有序排列；
        - 左侧节点消耗CPU时间较少，右侧节点消耗CPU时间较多。
        - 相对CPU时间是指绝对CPU时间与任务优先级的比值。即使用绝对CPU时间的低优先级任务比高优先级任务使用了更长的相对CPU时间。
    - 该算法总是优先调度使用相对CPU时间最短的任务。
    - 调度器只考虑可以运行的任务，其余任务放在等待队列中。每个任务可能需要等待的事件对应另一个等待队列。等待队列包含一个自旋锁，其目的是保证并发操作顺利进行。
    - 完全公平调度器虽然需要在O(logn)的时间复杂度内调度，但以目前的任务规模而言并不算难以接受。
  
  ___

- 线程同步：
  
  线程同步设施有互斥量、读写锁、条件变量、自旋锁、屏障等。

  - 互斥量

    - 互斥量本质上是一把锁。在访问数据前加锁，其他线程此后均不能获得这把锁。如果其他线程试图获得锁，则阻塞/返回。访问数据结束之后释放锁，以便其他线程可以访问数据。
    - 一个线程对一个互斥量连续加锁两次会导致死锁。多个线程互相请求对方持有的互斥量也会导致死锁。
      - 避免死锁的一种方法是以trylock调用代替lock调用，当不能获得锁时返回错误码，并释放自己持有的锁，做一些清理工作，稍后再重新请求锁。
    - 线程试图获取一个加锁的互斥量时可以调用timedlock，该方法允许线程在指定时间内一直请求获得锁，若超时则返回错误码。
    - pthread调用接口：

    ``` C
    int pthread_mutex_init(pthread_mutex_t* restrict mutex,
                            const pthread_mutexattr_t* restrict attr)
    int pthread_mutex_destroy(pthread_mutex_t* mutex)
    int pthread_mutex_lock(pthread_mutex_t* mutex)
    int pthread_mutex_trylock(pthread_mutex_t* mutex)
    int pthread_mutex_unlock(pthread_mutex_t* mutex)
    int pthread_mutex_timedlock(pthread_mutex_t* restrict mutex,
                            const struct timespec* restrict tsptr)
    ```
  
  - 读写锁/共享互斥锁
  
    - 读写锁比互斥锁允许更高的并行性。读写锁有三种形态：读模式下加锁、写模式下加锁、不加锁。写锁只允许一个线程获得，而读锁可以允许多个线程获得。
    - 读写锁的行为如下：
      - 当锁处于写加锁状态时，阻塞其他任何试图获得锁的线程，直到释放写锁；
      - 当锁处于读加锁状态时，允许其他线程获得读锁，阻塞其他线程获得写锁。当有试图获得写锁的线程在读写锁上阻塞时，阻塞其他试图获得读锁的线程，以避免读锁长时间被占用。
  
    - 读写锁适合用于读需求远高于写需求的场景。在这种场景下使用读写锁可获得更高的并发性。
    - 读写锁必须在使用前初始化，在使用后销毁。
    - 同样可使用timedlock避免永久阻塞。
    - pthread调用接口：
  
    ``` C
    //...
    int pthread_rwlock_rdlock(pthread_mutex_t* mutex)   //请求读锁
    int pthread_rwlock_timedrdlock(pthread_mutex_t* mutex)
    int pthread_rwlock_wrlock(pthread_mutex_t* mutex)   //请求写锁
    int pthread_rwlock_timedwrlock(pthread_mutex_t* mutex)
    //...
    ```

  - 条件变量
  
    - 条件变量允许线程以无竞争的方式等待条件发生。
    - 条件由互斥量保护，线程在改变条件状态时必须先锁住互斥量。
    - 条件变量必须先行初始化。
    - 条件变量有wait和signal两个方法。wait方法允许线程在条件变量上等待，signal方法允许条件变量唤醒在它上面等待的线程。
    - 使用while循环判断条件，避免线程被唤醒之后发现条件不成立而继续等待的情况。
    - pthread调用接口：

    ``` C
    //...
    int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex)
    int pthread_cond_timedwait(pthread_cond_t* cond,
            pthread_mutex_t* mutex, const struct timespec* tsptr)
    int pthread_cond_signal(pthread_cond_t* cond)   //通知在cond上等待的至少一个线程
    int pthread_cond_broadcast(pthread_cond_t* cond)    //通知在cond上等待的所有线程
    //...
    ```

  - 自旋锁
    - 自旋锁在获取锁之前一直处于忙等待状态。可用于以下情况：锁被持有的时间短，且线程不希望被重复调度。
    - 自旋锁可作为底层原语以实现其他锁。
      - 典型例子为汇编指令TSL（test and set lock）。下列汇编语句：TSL RX LOCK   将内存地址LOCK读到寄存器RX中，然后在LOCK上存放一个非零值，之后锁住内存总线。在CPU0上屏蔽中断并不能屏蔽CPU1读内存引发的中断，因此只能通过锁住内存总线的方式实现同步。这条指令需要多核处理器的支持。
    - 自旋锁可以通过设置参数而被**其他进程**的线程请求访问。
    - 试图加锁已经加锁的自旋锁是未定义行为，可能导致返回错误码或永久自旋。试图解锁已经解锁的自旋锁也是未定义行为。
    - pthread调用接口：

    ``` C
    //...
    int pthread_spin_lock(pthread_spinlock_t* lock)
    int pthread_spin_trylock(pthread_spinlock_t* lock)
    int pthread_spin_unlock(pthread_spinlock_t* lock)
    //...
    ```

  - 屏障
    - 屏障用于使多个线程协调工作。屏障可以允许每个线程等待，直到屏障上的所有线程都运行到同一点，然后从该点继续运行。join就是一种类型的屏障，它要求一个线程等待直到另一个线程退出。而屏障的概念更广，它不要求线程必须运行到退出点。
    - 初始化屏障需要指定合作线程的数量。当执行屏障的wait方法时，每有一个线程运行至屏障则增加屏障内的计数器，当前线程阻塞，直到计数器满足要求时唤醒全部进程。
    - pthread调用接口：

    ``` C
    //...
    int pthread_barrier_wait(pthread_barrier_t* barrier)
    //...
    ```
