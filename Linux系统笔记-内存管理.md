# Linux系统

## 内存管理

- 每个Linux进程都有一个地址空间，由代码、数据、堆栈组成。

  - 代码段包括所有机器指令，是只读的。
  - 数据段包括变量、字符串、数字等的存储，分为初始化数据和未初始化数据，其中未初始化数据在程序加载（exec）时被初始化为0。可以通过写时复制机制避免分配一些全为0的物理页框。
    - 数据段的大小可以通过brk系统调用改变。
    - 可以通过内存映射文件访问文件数据，该方法比read/write更高效。此时进程对文件数据的改变会被其他打开这个文件的进程看到。这提供了进程通信的另一种方式：共享文件。
  
  - 堆栈段从虚拟地址空间的顶部开始向低地址方向生长。程序启动的时候，它的栈包含了所有环境变量和上层调用的命令行参数。
  
  - 系统调用接口：
  
    ``` C
    brk(addr);
    //将数据段设定至指定地址addr
    mmap(addr, len, prot, flags, fd, offset);
    //将已打开的文件fd从offset位置开始映射len字节至addr。
    //prot控制被映射文件的权限（rwx），flags说明是否需要创建文件的一个副本。
    //子进程可通过fork继承存储映射区，而新程序不能通过exec继承存储映射区。
    ```

### 内存管理的实现

- 物理内存管理

  - 物理内存分为三部分：内核部分、DMA操作部分、正常页面。其中内核部分和DMA操作部分固定在内存中不被换出。其他部分被划分为页框，每个页框可表示一个代码/数据/栈页面、一个页表页面或者空闲页面。

  - 内核维护一组内存映射，该映射包含所有物理内存的使用情况，如下：

    - 内核维护一个页描述符数组。每个页描述符都拥有一个指针，在页面被占用时指向它的地址空间。另有一对指针用于将空闲页框和其他区域连接形成双向链表。
    - 内核为每个区域维护区域描述符，包含每个区域内存利用情况的信息和一些页面置换算法需要的信息。区域描述符还包含空闲区数组，该数组第i个元素标记所有含有2^i个空闲页的第一个块的第一个描述符。这些描述符由自身的指针连在一起。
    - 内核维护一个四级页表。
  
- 内存分配算法

  - 分配物理内存的主要机制为伙伴算法。
  
    - 伙伴算法的思路是将内存请求向上舍入到2的整数次幂，之后对内存连续进行二分，直到刚好得到大小合适的内存块。伙伴算法可快速找到2的幂次大小内存块，同时会为65页面的内存请求分配128页面。
      - 算法维护11个块链表，分别包含块大小为1、2、4、8、……、1024个连续页框的元素。假设请求一个大小为256页框的块，则先寻找256的链表，如果链表为空则寻找512的链表，……如果1024链表为空则返回错误。假设在512的链表中找到空闲块，则将其二分，一部分插入256链表，另一部分满足分配要求。
      - 内核试图将两个大小为b的空闲块合并为一个大小为2b的块，而且试图对所有11个链表都这么做。
  - 为缓解内存浪费问题，Linux有一层额外的slab分配器。
    - slab在伙伴算法分配的内存块上再次进行切分，将切分得到的小内存块缓存到对象缓存器，用于满足内核频繁创建销毁对象的需要（如task_struct）。slab可以存储相同类型的大量对象；每个slab可以是全满的，也可能是部分填充的，也可能是空的。
    - 当内核创建一个新的task_struct时，首先在部分填充的slab中找到一块内存并分配对象。如果没有部分填充的slab，就试图在空slab中完成操作。最后才试图分配新的slab并将其连接到task对象缓存中。

- 虚拟地址空间

  - 虚拟地址空间被分割成连续页面对齐的区域。区之间可以有空隙，对空隙的访问会导致段错误。页面大小由内核确定，一经确定不再变更。区是逻辑上的概念。一个进程可以有代码区、数据区、堆栈区等。
  - 每个区用vm_area_struct描述。
    - vm_area_struct描述区的属性有：读写权限、是否固定在内存、生长方向、是否私有等。
    - 一个进程的所有vm_area_struct用链表连在一起。同时这些vm_area_struct被组织成红黑树，提供快速查找的优化。
    - 调用fork之后，子进程会复制一份区链表，让父子进程以不同的链表指向相同的页面。对子进程而言，页面被标记为只读，而区标记为可读可写。这样当子进程试图写入页面的时候，系统认为该页面为写时复制页面，因此复制一个页面，对子进程标记为可读可写。
    - vm_area_struct记录这个区是否在磁盘上有备份存储，用于换入换出的情况。
  
- 分页系统

  - 内存的基本管理单元是页，几乎所有的内存管理操作都以页为单位。
  - Linux分页的思路：一个进程并不需要把所有数据都放在内存中，实际上只需要有页表就可以让进程可以被调度运行。在进程被调度运行之后，动态载入代码、数据、堆栈等。
  - 分页系统由内核和页面守护进程实现。页面守护进程周期性运行，寻找是否有工作要做，例如释放更多页面。

- 页面置换算法（PFRA）

  - 页面回收算法必须在用完空闲内存之前实行。释放一个页框需要将其数据写入磁盘，而I/O数据传送需要分配缓冲区，在没有多余空闲块时无法分配缓冲区，导致系统崩溃。
  - PFRA将页面分为不可回收页、可交换页、可同步页、可丢弃页。
    - 不可回收页包括内核内存页、空闲页、锁定的页面。这些页面无需回收。
    - 可交换页包括用户态匿名页（进程私有页）。回收时将其保存至交换区。
    - 可同步页包括用户态映射页（映射至某个文件）、磁盘缓存页。回收时需要先与磁盘同步。
    - 可丢弃页包括缓存中未使用的页面。回收时只需将其丢弃。
  
  - PFRA的总体原则：
    - 首先回收未被使用的缓存页面；
    - 必须可以回收任意用户态进程页面；
    - 必须先取消共享页框的所有页表项映射，才可以回收共享页框；
    - 只回收最近最少使用页面。
  
  - PFRA的周期回收机制：kswapd进程、cache_reap()、pdflush进程。
    - kswapd负责从LRU链表中回收页；
    - cache_reap()周期性的从slab分配器中回收未用的slab；
    - pdflush定期将脏页面写回磁盘；